setwd(dirname(rstudioapi::getActiveDocumentContext()$path))
source("01 数据处理.R", encoding = "UTF-8")

library(plm)
library(lmtest)
library(car)
library(psych)

# ============ 1. 主成分分析 ============
cat("\n========== 主成分分析 ==========\n")

# 数值变量并标准化
numeric_vars <- c(
  "GDP", "PGDP", "TER_GDP", "APC", "WAGE", "RD",
  "OPEN", "TRANS", "STHC", "STHC_ns", "PATENT"
)
X_scaled <- scale(df[, numeric_vars])

# PCA分析
pca_result <- principal(X_scaled, nfactors = ncol(X_scaled), rotate = "none")
eigenvalues <- pca_result$values

# 方差贡献率表
variance_pct <- eigenvalues / sum(eigenvalues) * 100
variance_table <- data.frame(
  PC = paste0("PC", 1:length(eigenvalues)),
  特征值 = round(eigenvalues, 3),
  方差贡献率 = paste0(round(variance_pct, 2), "%"),
  累计贡献率 = paste0(round(cumsum(variance_pct), 2), "%")
)
print(variance_table)

# 确定主成分数量
n_pc <- sum(eigenvalues > 1) # Kaiser准则
cat("\n保留", n_pc, "个主成分（特征值>1）\n")

# 构建主成分数据集
df_pca <- data.frame(
  Year = df$Year,
  Region = df$Region,
  Province = df$Province,
  FDI = df$FDI,
  pca_result$scores[, 1:n_pc]
)
colnames(df_pca)[5:(4 + n_pc)] <- paste0("PC", 1:n_pc)

# ============ 2. 主成分回归 ============

pc_formula <- as.formula(paste("FDI ~", paste0("PC", 1:n_pc, collapse = " + ")))
model_lm <- lm(pc_formula, data = df_pca)
summary(model_lm)

# ============ 3. 还原原始系数 ============
cat("\n========== 还原原始系数 ==========\n")

# 1. 提取主成分回归的系数（去掉截距项 Intercept）
# model_lm$coefficients 的第一个是截距，后面是 PC1, PC2...
beta_pc <- coef(model_lm)[-1] 

# 2. 提取 PCA 的权重矩阵 (Weights)
# 注意：只提取被保留的那 n_pc 个主成分的权重
# psych 包的 principal 结果中，weights 矩阵就是我们要的变换矩阵
W <- pca_result$weights[, 1:n_pc]

# 3. 计算针对“标准化数据”的回归系数
# 矩阵乘法：[变量数 x n_pc] * [n_pc x 1] = [变量数 x 1]
beta_scaled <- W %*% beta_pc
colnames(beta_scaled) <- c("Coefficient_Scaled")

# 4. (可选) 还原为针对“原始数据”的系数
# 公式：原始系数 = 标准化系数 / 原始变量的标准差
# 因为 X_scaled = (X - mean) / sd，所以回归系数会有 1/sd 的缩放
original_sds <- apply(df[, numeric_vars], 2, sd) # 计算原始变量的标准差
beta_original <- beta_scaled / original_sds

# 整理结果展示
coef_summary <- data.frame(
  Variable = rownames(beta_scaled),
  Scaled_Coef = round(beta_scaled, 5),   # 标准化后的系数（通常用于比较影响力大小）
  Original_Coef = round(beta_original, 5) # 原始量纲下的系数
)

print(coef_summary)

# 
# # ============ 3. 面板模型 ============
# cat("\n========== 面板模型选择 ==========\n")
# 
# pdata <- pdata.frame(df_pca, index = c("Province", "Year"))
# 
# # 三种模型
# pool <- plm(pc_formula, data = pdata, model = "pooling")
# fe <- plm(pc_formula, data = pdata, model = "within")
# re <- plm(pc_formula, data = pdata, model = "random")
# 
# # 模型检验
# cat("\n1. F检验 (混合OLS vs 固定效应):\n")
# f_test <- pFtest(fe, pool)
# print(f_test)
# 
# cat("\n2. LM检验 (混合OLS vs 随机效应):\n")
# lm_test <- plmtest(pool, type = "bp")
# print(lm_test)
# 
# cat("\n3. Hausman检验 (固定效应 vs 随机效应):\n")
# hausman <- phtest(fe, re)
# print(hausman)
# 
# # 选择最优模型
# final_model <- if (hausman$p.value < 0.05) fe else re
# model_name <- if (hausman$p.value < 0.05) "固定效应" else "随机效应"
# 
# cat("\n========== 最终模型:", model_name, "==========\n")
# summary(final_model)
